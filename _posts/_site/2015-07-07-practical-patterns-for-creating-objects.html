<h3 id="table-of-contents">Table of contents</h3>
<ul>
  <li><a href="#factory-pattern">Factory Pattern</a></li>
  <li><a href="#prototype-pattern">Prototype Pattern</a></li>
  <li><a href="#combination-of-constructor-prototype-pattern">Combination of Factory/Prototype</a></li>
</ul>

<h3 id="factory-pattern">Factory Pattern</h3>

<p>```javascript
function createCar(make, model, year) {
    var o = new Object();</p>

<pre><code>o.make   = make;
o.model  = model;
o.year   = year;
o.sayCar = function() {
    alert('I have a ' + this.year + ' ' + this.make + ' ' + this.model + '.');
};

return o; }
</code></pre>

<p>// create 2 car objects for John and Jane
var johnCar = createCar(‘Ford’, ‘F150’, ‘2011’),
    janeCar = createCar(‘Audi’, ‘A4’, ‘2007’);
```</p>

<p>Cons
1. Efficiency, functions are copied to all new object instances
2. Type determination. new object instances are typed as object</p>

<h3 id="constructor-pattern">Constructor Pattern</h3>

<p><code>javascript
function Fruit (theColor, theSweetness, theFruitName, theNativeToLand) {
​
    this.color = theColor;
    this.sweetness = theSweetness;
    this.fruitName = theFruitName;
    this.nativeToLand = theNativeToLand;
​
    this.showName = function () {
        console.log("This is a " + this.fruitName);
    }
​
    this.nativeTo = function () {
    this.nativeToLand.forEach(function (eachCountry)  {
       console.log("Grown in:" + eachCountry);
        });
    }
​
​
}
</code></p>

<p>To create</p>

<p><code>
var mangoFruit = new Fruit ("Yellow", 8, "Mango", ["South America", "Central America", "West Africa"]);
mangoFruit.showName(); // This is a Mango.​
mangoFruit.nativeTo();
</code></p>

<p>Solves type determination
But still <strong>ineffiecient</strong></p>

<h3 id="prototype-pattern">Prototype Pattern</h3>

<p><code>javascript
function Fruit () {
​
}
​
Fruit.prototype.color = "Yellow";
Fruit.prototype.sweetness = 7;
Fruit.prototype.fruitName = "Generic Fruit";
Fruit.prototype.nativeToLand = "USA";
​
Fruit.prototype.showName = function () {
console.log("This is a " + this.fruitName);
}
​
Fruit.prototype.nativeTo = function () {
            console.log("Grown in:" + this.nativeToLand);
}
</code></p>

<p><code>
var mangoFruit = new Fruit ();
mangoFruit.showName(); //​
mangoFruit.nativeTo();
</code></p>

<h3 id="combination-of-constructorprototype-pattern">Combination of Constructor/Prototype Pattern</h3>

<p><strong>The most popular one</strong></p>

<p>```
// constructor function to create car objects
function Car(make, model, year) {
    this.make   = make;
    this.model  = model;
    this.year   = year;
}</p>

<p>// constructor prototype to share properties and methods
Car.prototype.sayCar = function() {
    alert(‘I have a ‘ + this.year + ‘ ‘ + this.make + ‘ ‘ + this.model + ‘.’);  <br />
};</p>

<p>// create 2 car objects for John and Jane
var johnCar = new Car(‘Ford’, ‘F150’, ‘2011’),
    janeCar = new Car(‘Audi’, ‘A4’, ‘2007’);
```</p>

<ol>
  <li>Solves the efficiency issue by utilizing prototypal inheritance, share properties and methods on the constructor function’s prototype</li>
</ol>

